#include<iostream>

class CParent
{
protected:
	int			m_i;

public:
	void SetInt(int _a)
	{
		m_i = _a;
	}
public:
	CParent()
		: m_i(0)
	{}
	CParent(int a)
		:m_i(a)
	{}
	~CParent()
	{}
};

class CChild : public CParent //상속받음. 부모클래스의 기능을 사용가능. 
{
private:
	float		m_f;
public:
	void SetFloat(float _f)
	{
		m_f = _f;
		m_i = 100; // m_i 가 부모클래스에서 private로 선언되었으므로 자식클래스에서 접근이 안됨.
		// 그렇다고 m_i를 public:으로 선언하면 외부에서 마음대로 접근할 수 있다는 접근이 생김. 
		// 이럴떄 사용하는 접근 제한 지정자. protected: private 처럼 쓰지만 자식쪽에서 접근할 수는 있음. 
	}

public:
	CChild() // 상속받은 클래스에서 부모클래스의 멤버변수까지 초기화 하면 안됨. 초기화 만큼은 각자 자기의 생성자에서 초기화 해야됨. 
		: //CParent(); 이게 생략되어 있음. 
		m_f(0)
		, CParent(1000) // 이런식으로 거꾸로 적어도 부모 객체의 생성자가 먼저 초기화 됨. 이건 규칙임. 
	// 이런식으로 기본생성자가 아닌 다른 생성자를 호출하고 싶으면 명시적으로 오버로딩된 해당 생성자에 맞춰서 적어줘야함.  
	{
		m_i = 0; //이런건 초기화가 아니고 값을 넣어준것이기 때문에 괜찮음. .** 면접에서 나올 수 있음 
	}
	~CChild()
	{}
};
class CChildchild : public CChild // 이러면 CParent의 기능도 사용가능. 
{
private: long long m_ll;
};
int main()
{
	// 객체지향 언어 특징
	// 1. 캡슐화 (은닉성 : 어떤 부분은 외부에 공개하고 숨길지)
	//    내가 목적으로 하는 기능을 수행하기 위해서 필요한 데이터 멤버들, 서포팅해줄 수 있는 멤버함수들을 클래스라는 곳에 모아서 정의를함.
	//    그 클래스가 객체화를 통해서 어떤 역할을 수행할 수 있을지 이런것들을 구현할 수 있게 해줌. 
	// 2. 상속
	//	  어떤 클래스가 다른 클래스를 상속받는 다는 것은 부모 클래스의 기능을 기본적으로 가지고 있으면서 자식 클래스에서 추가적인 것을 구현하는 것임. 
	//	  자식클래스가 부모클래스와 똑같은 기능을 구현할 필요 없이 코드의 재사용성을 높이기 위해 상속하는것임. 


	CParent parent; 
	CChild child; // 부모클래스를 상속받은 클래스의 객체를 만듬
				  // 이렇게 상속받은 클래스의 객체를 만들면 객체의 크기는 부모의 크기 + 자신의 크기임
				  // 즉 CParent의 크기 4byte + 본인의 크기 4byte = 8byte임. 
				  
	CChild child1;
	// 이렇게 상속받은 클래스의 객체는 각 파트의 생성자가 각자 호출됨. 즉 CParent의 생성자와 CChild의 객체가 각자 호출됨. 
	// 즉. 생성자를 만들때 각자 멤버변수는 각자 초기화 해야됨. 자식클래스에서 부모클래스의 멤버변수까지 같이 초기화 하면 안됨. 
	// 생성자가 호출되는 순서는 자식 -> 부모임. 
	// 초기화 순서는 부모 -> 자식. 
	// 호출하는 주체가 자식클래스이기 때문에. 실행은 부모가 먼저 끝나고 자식이 끝나지만. 호출은 자식 클래스가 먼저되고 그 뒤에 부모클래스가 됨. 
	

	// 즉 시작주소로부터 부모바트부터 자식파트까지 메모리상 데이터가 순서대로 잡힘.ㅁㅁㅁ 이런식으로 

	// 부모클래스의 private로 선언된 부분은 자식클래스에서 접근 할 수 없음 .
	// protected:
	//    기본적으로 private랑 같지만 상속된 자식에서 접근할 수 있음. 
	parent.SetInt(10);
	child.SetInt(10); // 하지만 이렇게는 됨. 

	// 상속
	// 1. 상속받은 클래스의 메모리는 시작주소로부터 부모파트부터 자식파트까지 메모리상 데이터가 순서대로 잡힘
	// 2. protected : private는 자식클래스에서 접근 할 수 없지만 protected는 접근 할 수있음. 
	// 3. 부모클래스의 멤버함수를 자식클래스에서 호출가능. 
	// 4. ** 생성자가 호출되는 순서는 자식 -> 부모지만 멤버변수가 초기화 되는 순서는 부모 -> 자식임. 
	// 5. 자식의 생성자를 호출할때 호출되는 부모생성자는 기본생성자. 오버로딩한 다른 생성자를 호출하고 싶으면 명시해줘야함. 
	
	// 상속
	// 자식  or 부모 클래스는 상속관계에서 다른 클래스의 멤버를 초기화 할 수 없다. 
	// 생성자 호출 순서 자식 -> 부모
	// 생성자 실행 순서. 부모 -> 자식. 
	// 오버라이딩 : 부모 클래스의 멤버함수를 자식쪽에서 재정의 함으로써, 자식 클래스에 구현된 기능이 호출되도록 한다. 
	// 소멸자 실행 및 호출 순서, 자식 -> 부모
	return 0;
}