#include <iostream>
#include "CArr.h"
#include "Arr.h"

int main()
{
	// 객체 지향 언어 특징
	// 1. 캡슐화
	// 기능을 수행하기 위해 필요한 멤버 선언, 묶음, 은닉성
	// 멤버 함수들

	// 2. 상속

	// 3.다형성

	// 4. 추상화

	// 구조체 버전 가변배열 --> 클래스 버전

	// C++ 동적할당 new, delete
	// malloc은 사용자가 원하는 크기만큼 공간을 잡아 사용자가 원하는 자료형으로 사용하는 것. 태생이 int 거나 float이 아님. 그 공간을 어떻게 사용할지는 사용자가 적절한 포인터로 가리켜서 사용하는거임. 
	// 즉 malloc은 어떤 목적으로도 그 공간이 쓰일 수 있음. 
	// 컴파일러는 이 힙 메모리 공간에 클래스 객체가 들어온다는 확신이 있어야 함. (어떤 자료형으로 쓸지) 
	// new, 와 delete는 동적할당 할때 그 공간이 어떤 자료형으로 쓰일지 컴파일러에게 알려줌. (포인터로 안가르켜도)
	// 클래스에서는 사용자가 호출하지 않아도 생성자를 자동으로 호출할 필요성이 생겼기 때문애 동적할당 할때에도 이 자료형이 얼마만큼 들어갈지 알려줄 필요성이 생김. 

	// CArr 예시
	// 구조체를 이용한 가변배열
	tArr arr = {};
	InitArr(&arr);

	PushBack(&arr, 10);
	PushBack(&arr, 20);
	PushBack(&arr, 30);

	ReleaseArr(&arr);

	// 클래스 버전 가변 배열

	CArr carr;
	carr.push_back(10);
	carr.push_back(20);
	carr.push_back(30);
	
	int iData = carr[1];
	carr[1] = 40; //이런건 원래 말이 안됨. 클래스 이름이지 배열이름이 아니기 때문에 따라서 연산자 오버로딩으로 해주면 됨. 
	// 레퍼런스로 함수를 만들면 원본도 바뀜. 
				  
				  // 이런식으로 간편해짐. 초기화랑 해제를 안해도 됨. 
	return 0;

}