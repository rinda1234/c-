#include <iostream>

void Test(int);
void Test(int*);
int main()
{
	// 포인터 변수
	//주소를 가지는 기본 단위 1byte : byte단위로 주소가 존재함. 100번지 부터 102지번지 까지의 용량은 2바이트
	//포인터 변수를 선언할때 
	int i = 0;
	float f = 3.f;

	int* pInt = &i; //이건 int로 만들었으므로 주소에 접근할때 4바이트만 접근하겠다는 의미. ( 만약 주소가 int변수가 아닌 다른 바이트의 변수의 주소에 접근하면 책임 안짐. )
	/*int* pFloat = &f;*/ // 이건 같은 4바이트 라도 타입명이 다르므로 사용하면 안됨. 
	int* pFloat = (int*)&f; // 이런식으로 강제로 할 수 있지만 하면 안됨. 
	(*pInt) = 100; // i에 100저장


	//주소로 접근
	i = *pFloat; // 이렇게 했을때 정수 3이 아닌 이상한 숫자가 나옴. 
	// int 포인터에 float 변수의 주소를 강제로 넣었음. 하지만 Int 포인터는 자신에게 들어온 주소를 int 라는 자료형으로 판단하기로함.
	// 따라서 실수형으로 적힌 3의 정수현으로 읽음. 따라서 이상한 수가 나옴. (메모리안에 데이터는 똑같은데 어떻게 해석하는지에 따라 다른값이 나옴. )

	// 주소를 저장
	char* pchar = nullptr;
	short* pshort = nullptr;
	// 포인터 변수의 크기는 고정이 아니라 플랫폼에 따른 가변 길이로 계산이 됨. 운영체제의 비트 수가 주소의 크기임 (64bit) 4byte로 표현할수 있는 주소의 가짓수 2^32  - 1개.  64비트(8byte) 단위의 처리단위이므로 2^64  - 1개의 주소 가짓수르 표현가능. 
	// 즉 우리 포인터 변수의 크기는 8byte

	int j = 0;
	int* pInt_1 = &j; 
	pInt_1 += 1; // 만약pInt_1이 100의 주소값을 저장하고 있을때 주소 값을 +1을 한다면 101이 아닌 104가됨. 
	// pInt_1은 가리키고 있는곳을 int로 보기때문에 주소값을 1증가시키라는 것은 다음 번에 int가 있다면 그 칸을 가리킴.
	// 해당 포인터 변수가 가리키고자 하는 데이터 타입에 따라 왔다갔다함. 
	
	// 정리
	// pInt는 int* 변수 이기 때문에, 기리키는 곳을 int 로 해석한다.
	// 따라서 주소값을 1증가하는 의미는 다음 int 위치로 접근하기 위해서 sizeof(int) 단위로 증가하게 된다. 

	// 포인터와 배열
	// 배열의 특징
	// 1. 메모리가 연속적인 구조이다. 
	// 2. 배열의 이른은 배열의 시작 주소이다. 

	int iArr[10] = {};
	
	*(iArr + 0) = 10; // 첫번째 칸에 넣기.                 이식을 간단하게 표현한게 iArr[0] = 10
	*(iArr + 1) = 10; // 단위가 int이므로 4바이트 증가한곳인 2번째 칸에 10을 넣음.  iArr[1] = 10;
	*(iArr + 2) = 10;
	*(iArr + 3) = 10; // 배열의 첫번째 인덱스가 0인이유


	// 포인터 이해 확인 문제
	// 
	// 문제 1.
	short sArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	int* pI = (int*)sArr; 
	int iData = *((short*)(pI + 2)); //int 포인터의 주소를 2칸 증가시켰으므로 주소가 8이됨. 그러나 short배열이므로 가리키는 배열의 인덱스는 5
	//또한 int 포인터는 4바이트이기 때문에 이대로 읽으면 5와 6을 동시에 읽기 때문에 문제가 생김
	// 따라서 앞에 short로 캐스팅해서 2바이트만 읽게 만듬
	printf("1번 문제 정ekq : %d\n ", iData); //5

	// 문제 2
	char cArr[2] = { 1, 1 };
	
	short* pS = (short*)cArr;

	iData = *pS;
	// 이렇게 하면 short포인터로 받아서 접근하기 때문에 2바이트로 봐서 257로 해석함. 

	printf("2번 문제 정답: %d\n",iData); // 0000000100000001  = 257 의 값이 나올듯 
	

	//간단한 문제
	int a = 100;
	Test(a);
	printf("출력 : %d\n", a);// 100;
	Test(&a);
	printf("출력 : %d\n", a);
	return 0;


}

void Test(int a) // 이렇게 하면 a의 값은 변하지 않음. 
{
	a = 500;
}
void Test(int* a)
{
	*a = 500;
}
