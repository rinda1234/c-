#include<iostream>
// 이진트리
// 자식을 가질수 있는 개수를 2개로 제한한것. 자식의 개수가 2개 이하. 

// 완전 이진 트리
// 루트를 기준으로 자식을 꽉꽉 채우는 이진트리. 즉 자식이 2개씩있어야함. 
// 완전이진트리는 보통 배열로 구현함. 
/*           1
           2   3
        4   5 6   7      */
// 이런식으로 번호를 매겨서 번호순대로 배열에 넣음.
// 완전 이진 트리에서는 2k + 1과 2k + 2이 자식노드의 인덱스임. 여기서 k 는 부모 노드의 인덱스.

// 이진탐색
// 1. 데이터가 정렬되어 있어야함. ** 이게 가장 중요함. 이 조건이 있어야 이진탐색을 할 수 있음. 
// 2. 해결해야 되는 데이터의 크기를 계속해서 절반으로 줄여가며 탐색하는 방법. 
// 이진탐색의 소요 시간(횟수) 은log n(탐색해야될데이터개수) 임
 //                                2


// 빅오 표기법
// 알고리즘의 시간 복잡도를 다룸. ( 연산의 횟수와 관계가 있음. )
// O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) 
// 이진탐색은 logn 이므로 2번째로 빠름. 

// 벡터와 리스트는 입력할때 O(1) 의 효율을 가지고 탐색할때 O(N)의 효율을 가짐.
// 이진트리는 입력할때 O(log n)의 효율을 가지지만 탐색할때도 log(N)의 효율을 가짐.
// 즉 탐색할때 효율은 이진트리가 더 빠름. 

/*
1. 전위순회
    먼저간곳에 일을 먼저 하고 왼쪽자식일을 처리하고 오른쪽자식일을 처리함

2.중위순회(in order)
    일을 먼저하지 않고 왼쪽 자식일을 처리하고 일을 한뒤 오른쪽 자식일을 처리함
    ** 중위 순회로 이진탐색트리에 접근했을때 데이터를 크기순서대로 정렬된 순서로 얻어갈수있음. 
    ** 이진탐색안의 iterator도 중위 순회로 접근함. 
    *중위 선행자(in order predecessor)
        중위 순회 기준(iterator 가 가르키는 노드)으로 내 이전에 있는 노드
    *중위 후속자(in order successor)
        중위 순회 기준으로 내 뒤에 있는 노드. 

        이런식으로 내가 원하는 노드를 logn의 효율로 찾을 수 있음. 
3.후위순회

    일을 먼저하지 않고 왼쪽과 오른쪽 자식일을 다 처리한뒤 일을함



    * 이진탐색트리의 문제점
        데이터의 입력이 순차적으로 될때
        ex) 1에서 1000까지 순차적으로 넣을때/ 
               1
                 2
                   3
                     4 
                       ...
            이런식으로 계속 오른쪽으로 늘어남. 
            따라서 제대로된 효율을 보기 어려움. 


     * 이진탐색트리가 제대로된 효율을 보려면 밸런스잡힌모양을 갖춰야함. 
     * 실제 상황에서는 이렇게 밸런스잡힌모양을 갖추기 힘듬 ( 데이터가 어떻게 들어올지 모르기 때문에.)
     * 따라서 실제로 쓸때에는 이진탐색트리만 가지고 탐색알고리즘을 구현하지 않음. 
     * self balanced BST( 자가 균형 이진탐색트리) 를 가지고 함. (ex)AVL 트리, Red-Black트리) https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
     * 자료가 한쪽으로 치우쳐져도 전체적으로 회전을 하면서 모양을 균등하게 유지함. 


     // 이진 탐색트리의 삭제
     1. 삭제할 노드가 단말노드인경우(리프노드, 자식노드 0개) 
        : 따로 가지고 있는 자식이 없기 때문에 그냥 노드를 지우면 됨. 
     2. 삭제할 노드가 자식노드를 한 개 가진 경우(왼쪽, 오른쪽)
        : 삭제된 자리를 하나있는 자식 노드로 대체하면 됨. 
     3. 삭제할 노드가 2개의 자식을 가진 경우
        : 삭제할 노드의 중위 후속자로 대체, 중위 후속자의 데이터를 삭제할 노드에 복사한 뒤 중위 후속자를 삭제. 
    
        if 루트노드를 삭제. ( 중위 순회 순서로 나타냄.)
            4                                5
        2       6            - >          2      6
     1     3  5    7                    1   3   X   7 
     
     */
