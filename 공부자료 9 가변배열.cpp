#include <iostream>
#include "Arr.h"
#include <time.h>
int g_1 = 100;
typedef struct _tafST
{
	//int iArr[g_1];// 사용자가 직접만든 자료형. 자료형 크기가 중간에 바뀌면 안됨. 프로그램을 실행시켜야 몇 바이트인지 모르는 자료형은 말이 안됨. ex) int가 4바이트인데 갑자기 8바이트가 되면 안됨.
}ST;
int amain()
{
	// 기변배열
	// 가변배열의 특징
	// 1. 실행도중에 크기가 변할 수 있음.
	// 2. 데이터가 배열처럼 연속됨. 
	//int arr[10]; //크기가 정해져있음.
	int a = 100;
	scanf_s("%d", &a); //이런식으로 a의 값이 변하면 배열의 크기가 몇일지 모르기 때문에 변수로 배열을 만들 수 없음. 
	// 배열 개수를 선언할 때에는 변수를 사용 할 수 없다.  
	//int arr[a] = {}; // 지역변수로는 이게 불가능하다. 프로그램이 컴파일될때 메인함수가 사용할 stack메모리가 정해지기 때문에 중간에 바뀌면 안됨. 
	

	// 즉 가변배열을 만들기 위해서는 힙 메모리 영역을 사용할 수 밖에 없음. 
	
	// 객체(Instance)
	// int,  int로 만들 수 있는 객체 int a
	// int a; 이런 변수 하나하나가 객체임. 

	// 가변배열이라는 자료형으로 객체를 만들거임. Arr.cpp, Arr.h
	tArr x = {};

	x.pInt = (int*)malloc(40); // int 10개가 들어감. 
	x.iCount = 0;
	x.iMaxCount = 10;// 어차피 객체를 만들때마다 값을 초기화 해줘야 되므로 초기화 함수를 만들어야함. 

	tArr s = {};
	InitArr(&s); // 초기화 함수. 

	//데이터 추가
	for (int i = 0; i < 10; ++i)
	{
		PushBack(&s, i);
	}
	//Reallocate(&s); //이런식으로 main 함수에서 데이터가 가득 찼을때 실행하는 게 아닌 그냥 실행해버릴 수 있음. 그래서 헤더파일에서 이 부분을 지워버림. main에서 이 함수르 ㄹ모르게


	// 난수(랜덤)
	rand(); // 종이에다가 무작위로 수를 적어서 그 페이지에 수를 순서대로 적는거. 즉 순서가 정해져있음. 여러번 수행해보면 패턴이 존재
	srand(time(nullptr)); //seed값을 통해서 이 여러장의 난수 페이지중 특정 부분의 수를 나열하는것. 즉 좀 더 보완. 이때 seed 값을 시간으로 하면 더 좋음. 


	//동적할당을 했으므로 main 함수가 끝나기 전에 해제해줘야함. 
	ReleaseArr(&x);
	ReleaseArr(&s);
	return 0;

}

// 1. 가변배열
// 스스로 구현 가능하게 복습할 것
// 2. 가변배열 안엔 넣은 데이터 정렬
//  - 버블 정렬