#include<iostream>
#include "Arr.h"

// C++ 에서는 구조체 이름을 재정의 해줄 필요 없음.

struct tMy
{

};
// class
class CMy
{
	// class와 구조체에 다른점. 
	// 접근 제한 지정자
	// privatd, protected, public

private:
	int m_i;
public: 
	int m_j;
	void SetInt(int i)
	{
		this->m_i = i; // 이런식으로 멤버함수 안에서는 private 변수에 접근 가능. 
		// this를 하는 이유: 이 함수를 호출하는 객체의 주소를 뜻함. 
		m_j = i; // this는 생략해도 됨. 
	}

	void SetInt2(CMy* _pthis, int i)
	{
		_pthis->m_i = i; // 위에 SetInt랑 같은 함수임. 원래 이런식으로 구현되어 있는데 컴파일러가 생략해주는게 위에 함수. 
		// 즉 이런 개념이라는 걸 알고있으면 좋음. 편하게 생략할 수 있게 해줌. 
	}


	// 생성자
	// 클래스 명하고 이름이 똑같고 반환타입이 없음.
	CMy() // 진짜 초기화는 아님. 초기화는 변수가 만들어지자마자 값이 들어가야하는데 쓰레기 값이 들어있다가 값이 들어가는거기 때문에
	{
		m_i = 100;
	}
	// 연산자 오버로딩 : 내가 내가 만든 클래스끼리 연산자를 호출했을때 이렇게 연산을 하겠다고 함수로 만들어 둔 것. 
	// 대입 연산자 c1 = c2를 했을때 c2의 멤버변수의 데이터가 c1의 멤버변수로 복사해주는 거
	CMy& operator =(const CMy& _Other) // operator =은 이 해당 클래스쪽에 대입연산자가 발생했을떄 호출되는 함수다. 라는 의미. 
	{
		// c1 = c2에서 c1이 = 함수를 호출한거고 c2가 _Other 임. 
		// 대입이기 때문에 c2 원본이  손상되면 안되므로 const &로 받아옴. 
		m_i = _Other.m_i;
		m_j = _Other.m_j;

		return *this; //만약 c1 =c2 = c3일때 return을 안해주면 c1은 대입할 인자가 없음. c2=c3 가 끝나고 반환을 해줘야 c1도 할수있음. 
	}

public:
	// 생성자
	// 이니셜라이져(문법)
	CMy()
		: m_i(100)
		, m_j(200) // 이런식으로 하면 변수가 많을때 보기 편함. 
	{
	}
	// 이런식으로 쓰면 변수가 만들어지자 마자 바로 값이 들어감. 이게 초기화.
	// 생성자는 객체가 만들어질때 자동으로 호출됨. 


	// 소멸자
	~CMy()
	{
	}

	// 만약 생성자랑 소멸자를 아무것도 작성하지 않아도 컴파일러가 알아서 만듬. 
	// 대신에 아무 기능도 없음. default 생성자, default 소멸자라고 부름. 

	// 멤버함수
	// 해당 클래스가 사용하는 전용함수
	// 해당 클래스의 객체가 필요함. 
	// 멤버함수를 객체를 통해서 호출하면, 해당 객체의 주소가 this 포인터로 전달된다. 


	// 레퍼런스
	// int* a; 이런 자료형 포인터 타입의 변수가 됨. 
	// *a;     역참조
	// &b;     주소값 반환
	// int& b  레퍼런스 변수 선언(참조자) 

	// 레퍼런스
	// c++에 추가된 기능
	// 포인터와 유사
	// 원본을 참조한다.
	// 참조변수를 통해서 직접적으로 원본을 수정 할 수 있다. 

	// const int&* a; 로 초기화 하면 원본을 수정 할 수 없다. 
	void Test()
	{

	}
};

int main()
{
	// C++ 클래스 특징
	


	// 객체 지향 언어 특징
	// 1. 캡슐화
	// 기능을 수행하기 위해 필요한 멤버 선언, 묶음, 은닉성
	// 멤버 함수들

	// 2. 상속
	
	// 3.다형성

	// 4. 추상화

	// 구조체 버전 가변배열 --> 클래스 버전

	// C++ 동적할당 new, delete
	// malloc은 사용자가 원하는 크기만큼 공간을 잡아 사용자가 원하는 자료형으로 사용하는 것. 태생이 int 거나 float이 아님. 그 공간을 어떻게 사용할지는 사용자가 적절한 포인터로 가리켜서 사용하는거임. 
	// 즉 malloc은 어떤 목적으로도 그 공간이 쓰일 수 있음. 
	// 컴파일러는 이 힙 메모리 공간에 클래스 객체가 들어온다는 확신이 있어야 함. (어떤 자료형으로 쓸지) 
	// new, 와 delete는 동적할당 할때 그 공간이 어떤 자료형으로 쓰일지 컴파일러에게 알려줌. (포인터로 안가르켜도)
	// 클래스에서는 사용자가 호출하지 않아도 생성자를 자동으로 호출할 필요성이 생겼기 때문애 동적할당 할때에도 이 자료형이 얼마만큼 들어갈지 알려줄 필요성이 생김. 






	tArr arr = {}; 
	InitArr(&arr);
	PushBack(&arr, 10);

	arr.iCount = 100; // 현재 데이터가 1개 있어서 iCount는 1인데 main함수에서 이런식으로 바꿔버리면 원래 값이랑 달라서 오류가남. 
	// 구조체에서는 이런 오류가 날 수 있지만 클래스는 접근 제한 지정자 덕분에 멤버를 외부에서 볼 수 없음,


	ReleaseArr(&arr);

	CMy c; // 이떄 생성자가 자동으로 호출됨. 
	//c.m_i; // 이런식으로 private는 안보임.
	c.m_j; //public으로 하면 보임. 
	c.SetInt(1);

	c.Test(); // 이런식으로 적어야함.
	//Test(); // 이건 안됨
	//CMy::Test(); //이것도안됨.   :: 범위지정연산자

	CMy c1;
	c1.SetInt(10);
	
	CMy c2;
	c2.SetInt(100);

	CMy c3;
	c3.SetInt(1000);

	c2 = c1;
	
	return 0;
}